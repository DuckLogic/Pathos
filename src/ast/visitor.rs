//! The AST visitor code

// File originally generated by asdl/rust.py.

use super::Span;
use super::constants::ConstantVisitor;
use crate::lexer::{Ident as RawIdent};
use crate::ast::tree::{
    Operator, ExprContext, Unaryop, Boolop,
    Cmpop
};


pub trait AstVisitor<'a>: ConstantVisitor<'a> {
    type Ident;
    type Err;

    fn create_ident(&mut self, span: Span, ident: &RawIdent<'a>) -> Result<Self::Ident, Self::Err>;

    fn create_keyword(
            &mut self,
            span: Span,
            arg: Option<Self::Ident>,
            value: Self::Expr,
    ) -> Result<Self::Keyword, Self::Err>;

    type ComprehensionBodyVisitor: ComprehensionBodyVisitor<'a>;
    fn visit_comprehension(
            &mut self,
            target: Self::Expr,
            iter: Self::Expr,
            is_async: bool,
    ) -> Result<Self::ComprehensionBodyVisitor, Self::Err>;
    fn visit_alias(
            &mut self,
            span: Span,
            name: Self::Ident,
            asname: Option<Self::Ident>,
    ) -> Result<Self::Alias, Self::Err>;
    fn visit_withitem(
            &mut self,
            context_expr: Self::Expr,
            optional_vars: Option<Self::Expr>,
    ) -> Result<Self::Withitem, Self::Err>;
    type MatchCaseBodyVisitor: MatchCaseBodyVisitor<'a>
        + AstVisitor<'a, MatchCase=Self::MatchCase>;
    fn visit_match_case(
            &mut self,
            pattern: Self::Pattern,
            guard: Option<Self::Expr>,
    ) -> Result<Self::MatchCaseBodyVisitor, Self::Err>;

    fn visit_type_ignore(
            &mut self,
            lineno: i32,
            tag: &'a str,
    ) -> Result<Self::TypeIgnore, Self::Err>;

    type Mod;
    type Stmt;
    type Expr;
    type Comprehension;
    type Arguments;
    type Arg;
    type Keyword;
    type Alias;
    type Withitem;
    type MatchCase;
    type Pattern;
    type TypeIgnore;
}

pub trait MatchCaseBodyVisitor<'a>: AstVisitor<'a> {
    fn visit_body_stmt(&mut self, stmt: Self::Stmt) -> Result<(), Self::Err>;
    fn finish(self, span: Span) -> Result<Self::MatchCase, Self::Err>;
}

pub trait ComprehensionBodyVisitor<'a>: AstVisitor<'a> {
    fn visit_if_stmt(&mut self, stmt: Self::Stmt) -> Result<(), Self::Err>;
    fn finish(self, span: Span) -> Result<Self::Comprehension, Self::Err>;
}
pub trait SpecificArgVisitor<'a>: AstVisitor<'a> {
    fn visit_annotation(&mut self, ann: Self::Expr) -> Result<(), Self::Err>;
    fn visit_default(&mut self, ann: Self::Expr) -> Result<(), Self::Err>;
    fn visit_type_commnt(&mut self, cmt: &'a str) -> Result<(), Self::Err>;
    fn finish(self, span: Span) -> Result<Self::Arg, Self::Err>;
} 
pub trait ArgumentsVisitor<'a>: AstVisitor<'a> {
    type Positional: SpecificArgVisitor<'a>;
    fn visit_positional_arg(
        &mut self,
        positional_only: bool,
        name: Self::Ident
    ) -> Result<Self::Positional, Self::Err>;
    type Vararg: SpecificArgVisitor<'a>;
    fn visit_vararg(
        &mut self,
        name: Self::Ident
    ) -> Result<Self::Vararg, Self::Err>;
    type KeywordArg: SpecificArgVisitor<'a>;
    fn visit_keyword_arg(
        &mut self,
        keyword_only: bool,
        name: Self::Ident,
    ) -> Result<Self::KeywordArg, Self::Err>;
    type KeywordVararg: SpecificArgVisitor<'a>;
    fn visit_keyword_vararg(&mut self, name: Self::Ident) -> Result<Self::KeywordVararg, Self::Err>;
    fn finish(&self, span: Span) -> Result<Self::Arguments, Self::Err>;
}

pub trait FunctionDefVisitor<'a>: AstVisitor<'a> {
    fn visit_body_stmt(&mut self, stmt: Self::Stmt) -> Result<(), Self::Err>;
    fn visit_type_comment(&mut self, cmt: &str) -> Result<(), Self::Err>;
    fn visit_return(&mut self, rtn: Self::Expr) -> Result<(), Self::Err>;
    fn finish(self, span: Span) -> Result<<Self as AstVisitor<'a>>::Stmt, Self::Err>;
}
pub trait ClassDefVisitor<'a>: AstVisitor<'a> {
    fn visit_body_stmt(&mut self, stmt: Self::Stmt) -> Result<(), Self::Err>;
    fn visit_base(&mut self, base: Self::Expr) -> Result<(), Self::Err>;
    fn visit_keyword(&mut self, keyword: Self::Keyword) -> Result<(), Self::Err>;
    fn finish(self, span: Span) -> Result<Self::Stmt, Self::Err>;
}
pub trait DecoratorVisitor<'a>: AstVisitor<'a> {
    type List;
    fn visit_decorator(&mut self, expr: Self::Expr) -> Result<(), Self::Err>;
    fn finish(self) -> Result<Self::List, Self::Err>;
}
/// Visits a 'simple' assignment
pub trait SimpleAssignVisitor<'a>: AstVisitor<'a> {
    fn visit_target(&mut self, target: Self::Expr) -> Result<(), Self::Err>;
    fn visit_value(&mut self, target: Self::Expr);
    fn visit_type_comment(&mut self, cmt: &str) -> Result<(), Self::Err>;
    fn finish(self, span: Span) -> Result<Self::Stmt, Self::Err>;
}

pub trait DeleteVisitor<'a>: AstVisitor<'a> {
    fn visit_target(&mut self, target: Self::Expr) -> Result<(), Self::Err>;   
    fn finish(self) -> Result<Self::Stmt, Self::Err>;
}
pub trait LoopVisitor<'a>: AstVisitor<'a> {
    fn visit_body_stmt(&mut self, stmt: Self::Stmt) -> Result<(), Self::Err>;
    fn visit_else_stmt(&mut self, stmt: Self::Stmt) -> Result<(), Self::Err>;
    fn visit_type_comment(&mut self, cmt: &'a str) -> Result<(), Self::Err>;
    fn finish(self, span: Span) -> Result<Self::Stmt, Self::Err>;
}
pub trait IfVisitor<'a>: AstVisitor<'a> {
    fn visit_body_stmt(&mut self, stmt: Self::Stmt) -> Result<(), Self::Err>;
    fn visit_else_stmt(&mut self, stmt: Self::Stmt) -> Result<(), Self::Err>;
    fn finish(self, span: Span) -> Result<Self::Stmt, Self::Err>;
}
pub trait WithVisitor<'a>: AstVisitor<'a> {
    fn visit_item(&mut self, item: Self::Withitem) -> Result<(), Self::Err>;
    fn visit_body_stmt(&mut self, body: Self::Stmt) -> Result<(), Self::Err>;
    fn finish(self, span: Span) -> Result<Self::Stmt, Self::Err>;
}
pub trait MatchCaseVisitor<'a>: AstVisitor<'a> {
    fn visit_case(&mut self, case: Self::MatchCase) -> Result<(), Self::Err>;
    fn finish(self, span: Span) -> Result<Self::Stmt, Self::Err>;
}
pub trait ExceptHandlerVisitor<'a>: AstVisitor<'a> {
    fn visit_body_stmt(&mut self, stmt: Self::Stmt) -> Result<(), Self::Err>;
    fn finish(self, span: Span) -> Result<(), Self::Err>;
}
pub trait TryVisitor<'a>: AstVisitor<'a> {
    fn visit_body_stmt(&mut self, stmt: Self::Stmt) -> Result<(), Self::Err>;
    type ExceptHandler: ExceptHandlerVisitor<'a>
        + AstVisitor<'a, Stmt=Self::Stmt>;
    fn visit_except_handler(
            &mut self,
            span: Span,
            ast_type: Option<Self::Expr>,
            name: Option<Self::Ident>,
    ) -> Result<Self::ExceptHandler, Self::Err>;
    fn visit_else_stmt(&mut self, stmt: Self::Stmt) -> Result<(), Self::Err>;
    fn visit_finally_stmt(&mut self, stmt: Self::Stmt) -> Result<(), Self::Err>;
    fn finsh(self, span: Span) -> Result<Self::Stmt, Self::Err>;
}
pub trait ImportVisitor<'a>: AstVisitor<'a> {
    fn visit_alias(&mut self, name: Self::Alias) -> Result<(), Self::Err>;
    fn finish(self, span: Span) -> Result<Self::Stmt, Self::Err>;
}
pub trait NameListVisitor<'a>: AstVisitor<'a> {
    fn visit_name(&mut self, name: Self::Ident) -> Result<(), Self::Err>;
    fn finish(self, span: Span) -> Result<Self::Stmt, Self::Err>;
}
pub trait StatementVisitor<'a>: AstVisitor<'a> {
    type FuncDef: FunctionDefVisitor<'a> + AstVisitor<'a, Stmt=Self::Stmt>;
    type AsyncFuncDef: FunctionDefVisitor<'a> + AstVisitor<'a, Stmt=Self::Stmt>;
    type Decorators: DecoratorVisitor<'a, List=Self::DecoratorList>;
    type DecoratorList;
    fn visit_decorators(&mut self) -> Self::Decorators;
    type ArgumentVisitor: ArgumentsVisitor<'a>;
    fn visit_arguments(&mut self) -> Self::ArgumentVisitor;
    fn visit_stmt_function_def(
        &mut self,
        decorators: Option<Self::DecoratorList>,
        args: Self::Arguments,
        name: Self::Ident
    ) -> Result<Self::FuncDef, Self::Err>;
    fn visit_stmt_async_function_def(
        &mut self,
        decorators: Option<Self::DecoratorList>,
        args: Self::Arguments,
        name: Self::Ident
    ) -> Result<Self::AsyncFuncDef, Self::Err>;
    type ClassDef: ClassDefVisitor<'a>;
    fn visit_stmt_class_def(
            &mut self,
            name: Self::Ident,
            decorators: Option<Self::DecoratorList>,
    ) -> Result<Self::ClassDef, Self::Err>;
    fn visit_stmt_return(
            &mut self,
            span: Span,
            value: Option<Self::Expr>,
    ) -> Result<Self::Stmt, Self::Err>;
    type Delete: DeleteVisitor<'a>
        + AstVisitor<'a, Stmt=Self::Stmt>;
    fn visit_stmt_delete(
            &mut self,
    ) -> Result<Self::Delete, Self::Err>;
    type SimpleAssign: SimpleAssignVisitor<'a>;
    fn visit_stmt_assign(
            &mut self,
    ) -> Result<Self::SimpleAssign, Self::Err>;
    fn visit_stmt_aug_assign(
            &mut self,
            span: Span,
            target: Self::Expr,
            op: Operator,
            value: Self::Expr,
    ) -> Result<Self::Stmt, Self::Err>;
    fn visit_stmt_ann_assign(
            &mut self,
            span: Span,
            target: Self::Expr,
            annotation: Self::Expr,
            value: Option<Self::Expr>,
            simple: bool,
    ) -> Result<Self::Stmt, Self::Err>;
    type LoopVisitor: LoopVisitor<'a>
        + AstVisitor<'a, Stmt=Self::Stmt>;
    fn visit_stmt_for(
            &mut self,
            target: Self::Expr,
            iter: Self::Expr,
    ) -> Result<Self::LoopVisitor, Self::Err>;
    fn visit_stmt_async_for(
            &mut self,
            target: Self::Expr,
            iter: Self::Expr,
    ) -> Result<Self::LoopVisitor, Self::Err>;
    fn visit_stmt_while(
            &mut self,
            test: Self::Expr,
    ) -> Result<Self::LoopVisitor, Self::Err>;
    type IfVisitor: IfVisitor<'a>
        + AstVisitor<'a, Stmt=Self::Stmt>;
    fn visit_stmt_if(
            &mut self,
            test: Self::Expr,
    ) -> Result<Self::IfVisitor, Self::Err>;
    type WithVisitor: WithVisitor<'a>
        + AstVisitor<'a, Stmt=Self::Stmt>;
    fn visit_stmt_with(
            &mut self,
    ) -> Result<Self::WithVisitor, Self::Err>;
    fn visit_stmt_async_with(
            &mut self,
    ) -> Result<Self::WithVisitor, Self::Err>;
    type MatchVisitor: MatchCaseVisitor<'a>
        + AstVisitor<'a, Stmt=Self::Stmt>;
    fn visit_stmt_match(
            &mut self,
            subject: Self::Expr,
    ) -> Result<Self::MatchVisitor, Self::Err>;
    fn visit_stmt_raise(
            &mut self,
            span: Span,
            exc: Option<Self::Expr>,
            cause: Option<Self::Expr>,
    ) -> Result<Self::Stmt, Self::Err>;
    type TryVisitor: TryVisitor<'a>
        + AstVisitor<'a, Stmt=Self::Stmt>;
    fn visit_stmt_try(
            &mut self,
    ) -> Result<Self::TryVisitor, Self::Err>;
    fn visit_stmt_assert(
            &mut self,
            span: Span,
            test: Self::Expr,
            msg: Option<Self::Expr>,
    ) -> Result<Self::Stmt, Self::Err>;
    type Import: ImportVisitor<'a>
        + AstVisitor<'a, Stmt=Self::Stmt>;
    fn visit_stmt_import(
            &mut self,
    ) -> Result<Self::Import, Self::Err>;
    type ImportFrom: ImportVisitor<'a>
        + AstVisitor<'a, Stmt=Self::Stmt>;
    fn visit_stmt_import_from(
            &mut self,
            span: Span,
            module: Option<Self::Ident>,
            level: Option<i32>,
    ) -> Result<Self::ImportFrom, Self::Err>;
    type GlobalVisitor: NameListVisitor<'a>
        + AstVisitor<'a, Ident=Self::Ident>;
    fn visit_stmt_global(
            &mut self,
    ) -> Self::GlobalVisitor;
    type NonLocalVisitor: NameListVisitor<'a>
        + AstVisitor<'a, Ident=Self::Ident>;
    fn visit_stmt_nonlocal(
            &mut self,
    ) -> Result<Self::NonLocalVisitor, Self::Err>;
    fn visit_stmt_expr(
            &mut self,
            span: Span,
            value: Self::Expr,
    ) -> Result<Self::Stmt, Self::Err>;
    fn visit_stmt_pass(
            &mut self,
            span: Span,
    ) -> Result<Self::Stmt, Self::Err>;
    fn visit_stmt_break(
            &mut self,
            span: Span,
    ) -> Result<Self::Stmt, Self::Err>;
    fn visit_stmt_continue(
            &mut self,
            span: Span,
    ) -> Result<Self::Stmt, Self::Err>;
}

pub trait BoolOpVisitor<'a>: AstVisitor<'a> {
    fn visit_value(&mut self, val: Self::Expr) -> Result<(), Self::Err>;
    fn finish(self, span: Span) -> Result<(), Self::Err>;
}
pub trait ComprehensionVisitor<'a>: AstVisitor<'a> {
    fn visit_comprehension(&mut self, comp: Self::Comprehension) -> Result<(), Self::Err>;
    fn finish(self, span: Span) -> Result<Self::Expr, Self::Err>;
}
pub trait ComparisonVisitor<'a>: AstVisitor<'a> {
    fn visit_compare(
        &mut self, op: Cmpop,
        expr: Self::Expr
    ) -> Result<(), Self::Err>;
    fn finish(self, span: Span) -> Result<Self::Expr, Self::Err>;
}
pub trait CallVisitor<'a>: AstVisitor<'a> {
    fn visit_arg(&mut self, arg: Self::Expr) -> Result<(), Self::Err>;
    fn visit_keyword(&mut self, kw: Self::Keyword) -> Result<(), Self::Err>;
    fn finish(self, span: Span) -> Result<Self::Expr, Self::Err>;
}
pub trait CollectionLiteralVisitor<'a>: AstVisitor<'a> {
    fn visit_element(&mut self, element: Self::Expr) -> Result<(), Self::Err>;
    fn finish(self, span: Span) -> Result<Self::Expr, Self::Err>;
}

pub trait JoinedStringVisitor<'a>: AstVisitor<'a> {
    fn visit_partial_string(&mut self, element: Self::Expr) -> Result<(), Self::Err>;
    fn finish(self, span: Span) -> Result<Self::Expr, Self::Err>;
}
pub trait ExpressionVisitor<'a>: AstVisitor<'a> {
    type BoolOpVisitor: ComprehensionVisitor<'a>
        + AstVisitor<'a, Expr=Self::Expr>;
    fn visit_expr_bool_op(
            &mut self,
            span: Span,
            op: Boolop,
    ) -> Result<Self::BoolOpVisitor, Self::Err>;
    fn visit_expr_named_expr(
            &mut self,
            span: Span,
            target: Self::Expr,
            value: Self::Expr,
    ) -> Self::Expr;
    fn visit_expr_bin_op(
            &mut self,
            span: Span,
            left: Self::Expr,
            op: Operator,
            right: Self::Expr,
    ) -> Self::Expr;
    fn visit_expr_unary_op(
            &mut self,
            span: Span,
            op: Unaryop,
            operand: Self::Expr,
    ) -> Self::Expr ;
    fn visit_expr_lambda(
            &mut self,
            span: Span,
            args: Self::Arguments,
            body: Self::Expr,
    ) -> Self::Expr ;
    fn visit_expr_if_exp(
            &mut self,
            span: Span,
            test: Self::Expr,
            body: Self::Expr,
            orelse: Self::Expr,
    ) -> Self::Expr ;
    fn visit_expr_dict(
            &mut self,
            span: Span,
            elements: impl Iterator<Item=(Self::Expr, Self::Expr)>,
    ) -> Self::Expr ;
    type SetLiteralVisitor: CollectionLiteralVisitor<'a>
        + AstVisitor<'a, Expr=Self::Expr>;
    fn visit_expr_set(
        &mut self,
    ) -> Result<Self::SetLiteralVisitor, Self::Err>;
    type ListCompVisitor: ComprehensionVisitor<'a>
        + AstVisitor<'a, Expr=Self::Expr>;
    fn visit_expr_list_comp(
            &mut self,
            span: Span,
            elt: Self::Expr,
    ) -> Result<Self::ListCompVisitor, Self::Err>;
    type SetCompVisitor: ComprehensionVisitor<'a>
        + AstVisitor<'a, Expr=Self::Expr>;
    fn visit_expr_set_comp(
            &mut self,
            span: Span,
            elt: Self::Expr,
    ) -> Result<Self::SetCompVisitor, Self::Err>;
    type DictCompVisitor: ComprehensionVisitor<'a>
        + AstVisitor<'a, Expr=Self::Expr>;
    fn visit_expr_dict_comp(
            &mut self,
            span: Span,
            key: Self::Expr,
            value: Self::Expr,
    ) -> Result<Self::DictCompVisitor, Self::Err>;
    type GeneratorVisitor: ComprehensionVisitor<'a>
        + AstVisitor<'a, Expr=Self::Expr>;
    fn visit_expr_generator_exp(
            &mut self,
            span: Span,
            elt: Self::Expr,
    ) -> Result<Self::GeneratorVisitor, Self::Err>;
    fn visit_expr_await(
            &mut self,
            span: Span,
            value: Self::Expr,
    ) -> Self::Expr ;
    fn visit_expr_yield(
            &mut self,
            span: Span,
            value: Option<Self::Expr>,
    ) -> Self::Expr ;
    fn visit_expr_yield_from(
            &mut self,
            span: Span,
            value: Self::Expr,
    ) -> Self::Expr ;
    type CompareVisitor: ComparisonVisitor<'a>
        + AstVisitor<'a, Expr=Self::Expr>;
    fn visit_expr_compare(
            &mut self,
            span: Span,
            left: Self::Expr,
    ) -> Result<Self::CompareVisitor, Self::Err> ;
    type CallVisitor: ComparisonVisitor<'a>
        + AstVisitor<'a, Expr=Self::Expr>;    
    fn visit_expr_call(
            &mut self,
            span: Span,
            func: Self::Expr,
    ) -> Result<Self::CallVisitor, Self::Err>;
    fn visit_expr_formatted_value(
            &mut self,
            span: Span,
            value: Self::Expr,
            conversion: Option<char>,
            format_spec: Option<Self::Expr>,
    ) -> Self::Expr ;
    type JoinedStrVisitor: JoinedStringVisitor<'a>
        + AstVisitor<'a, Expr=Self::Expr>;
    fn visit_expr_joined_str(
            &mut self,
    ) -> Result<Self::JoinedStrVisitor, Self::Err>;
    fn visit_expr_constant(
            &mut self,
            span: Span,
            value: Self::Constant,
            kind: Option<&'a str>,
    ) -> Self::Expr ;
    fn visit_expr_attribute(
            &mut self,
            span: Span,
            value: Self::Expr,
            attr: Self::Ident,
            ctx: ExprContext,
    ) -> Self::Expr ;
    fn visit_expr_subscript(
            &mut self,
            span: Span,
            value: Self::Expr,
            slice: Self::Expr,
            ctx: ExprContext,
    ) -> Self::Expr ;
    fn visit_expr_starred(
            &mut self,
            span: Span,
            value: Self::Expr,
            ctx: ExprContext,
    ) -> Self::Expr ;
    fn visit_expr_name(
            &mut self,
            span: Span,
            id: Self::Ident,
            ctx: ExprContext,
    ) -> Self::Expr ;
    type ListLiteralVisitor: CollectionLiteralVisitor<'a>
        + AstVisitor<'a, Expr=Self::Expr>;
    fn visit_expr_list(
            &mut self,
            span: Span,
            ctx: ExprContext,
    ) -> Result<Self::ListLiteralVisitor, Self::Err>;
    type TupleLiteralVisitor: CollectionLiteralVisitor<'a>
        + AstVisitor<'a, Expr=Self::Expr>;
    fn visit_expr_tuple(
            &mut self,
            span: Span,
            ctx: ExprContext,
    ) -> Result<Self::TupleLiteralVisitor, Self::Err>;
    fn visit_expr_slice(
            &mut self,
            span: Span,
            lower: Option<Self::Expr>,
            upper: Option<Self::Expr>,
            step: Option<Self::Expr>,
    ) -> Self::Expr ;
}

pub trait ModVisitor<'a>: AstVisitor<'a> {
    type Module: ModBodyVisitor<'a>;
    type Interactive: ModBodyVisitor<'a>;
    fn visit_mod_module(
            &mut self,
    ) -> Self::Module;
    fn visit_mod_interactive(
            &mut self,
    ) -> Self::Interactive;
    fn visit_mod_expression(
            &mut self,
            body: Self::Expr,
    ) -> Result<Self::Mod, Self::Err>;
}
pub trait ModBodyVisitor<'a>: AstVisitor<'a> {
    fn visit_body_stmt(&mut self, stmt: Self::Stmt) -> Result<(), Self::Err>;
    fn visit_type_comment(&mut self, cmt: &'a str) -> Result<(), Self::Err>;
    fn finish(self) -> Result<Self::Mod, Self::Err>;
}

pub trait SequencePatternVisitor<'a>: AstVisitor<'a> {
    fn visit_element_pattern(&mut self, pat: Self::Pattern) -> Result<(), Self::Err>;
    fn finish(self, span: Span) -> Result<Self::Pattern, Self::Err>;
}
pub trait MappingPatternVisitor<'a>: AstVisitor<'a> {
    fn visit_element_pattern(
        &mut self,
        key: Self::Expr,
        value: Self::Expr
    ) -> Result<(), Self::Err>;
    fn visit_rest(&mut self, name: Self::Ident) -> Result<(), Self::Err>;
    fn finish(self, span: Span) -> Result<Self::Pattern, Self::Err>;
}
pub trait ClassPatternVisitor<'a>: AstVisitor<'a> {
    fn visit_positional_pattern(
        &mut self,
        pat: Self::Pattern
    ) -> Result<(), Self::Err>;
    fn visit_keyword_pattern(
        &mut self,
        name: Self::Ident,
        pat: Self::Pattern
    ) -> Result<(), Self::Err>;
}
pub trait OrPatternVisitor<'a>: AstVisitor<'a> {
    fn visit_alternative(&mut self, pat: Self::Pattern) -> Result<(), Self::Err>;
    fn finish(self, span: Span) -> Result<(), Self::Err>;
}
pub trait PatternVisitor<'a>: AstVisitor<'a> {
    fn visit_pattern_match_value(
            &mut self,
            span: Span,
            value: Self::Expr,
    ) -> Result<Self::Pattern, Self::Err>;
    fn visit_pattern_match_singleton(
            &mut self,
            span: Span,
            value: Self::Constant,
    ) -> Result<Self::Pattern, Self::Expr>;
    type SequenceVisitor: SequencePatternVisitor<'a>
        + AstVisitor<'a, Pattern=Self::Pattern>;
    fn visit_pattern_match_sequence(&mut self,) -> Self::SequenceVisitor;
    type MappingVisitor: MappingPatternVisitor<'a>
        + AstVisitor<'a, Pattern=Self::Pattern>;
    fn visit_pattern_match_mapping(
            &mut self,
    ) -> Self::MappingVisitor ;
    type ClassVisitor: ClassPatternVisitor<'a>
        + AstVisitor<'a, Pattern=Self::Pattern>;
    fn visit_pattern_match_class(
            &mut self,
            span: Span,
            cls: Self::Expr,
    ) -> Result<Self::ClassVisitor, Self::Err> ;
    fn visit_pattern_match_star(
            &mut self,
            span: Span,
            name: Option<Self::Ident>,
    ) -> Self::Pattern ;
    fn visit_pattern_match_as(
            &mut self,
            span: Span,
            pattern: Option<Self::Pattern>,
            name: Option<Self::Ident>,
    ) -> Self::Pattern ;
    type OrVisitor: OrPatternVisitor<'a>
        + AstVisitor<'a, Pattern=Self::Pattern>;
    fn visit_pattern_match_or(&mut self,) -> Self::OrVisitor ;
}
