// File automatically generated by asdl/rust.py.
use super::Span;
use crate::lexer::{Ident as RawIdent};
use crate::ast::tree::{
    Operator, ExprContext, Unaryop, Binop, Cmpop
};

pub trait AstVisitor<'a> {
    type Ident;
    type Err;

    fn create_ident(&mut self, span: Span, ident: &RawIdent<'a>) -> Result<Self::Ident, Self::Err>;

    fn create_keyword(
            &mut self,
            span: Span,
            arg: Option<Self::Ident>,
            value: Self::Expr,
    ) -> Self::Keyword ;

    fn visit_comprehension(
            &mut self,
            target: Self::Expr,
            iter: Self::Expr,
            ifs: impl Iterator<Item=Self::Expr>,
            is_async: i32,
    ) -> Self::Comprehension ;
    fn visit_excepthandler_except_handler(
            &mut self,
            span: Span,
            ast_type: Option<Self::Expr>,
            name: Option<Self::Ident>,
            body: impl Iterator<Item=Self::Stmt>,
    ) -> Self::Excepthandler ;

    fn visit_alias(
            &mut self,
            span: Span,
            name: Self::Ident,
            asname: Option<Self::Ident>,
    ) -> Self::Alias ;
    fn visit_withitem(
            &mut self,
            context_expr: Self::Expr,
            optional_vars: Option<Self::Expr>,
    ) -> Self::Withitem ;
    fn visit_match_case(
            &mut self,
            pattern: Self::Pattern,
            guard: Option<Self::Expr>,
            body: impl Iterator<Item=Self::Stmt>,
    ) -> Self::MatchCase ;
    
    fn visit_type_ignore_type_ignore(
            &mut self,
            lineno: i32,
            tag: &'a str,
    ) -> Self::TypeIgnore ;

    type Mod;
    type Stmt;
    type Expr;
    type Comprehension;
    type ExceptHandler;
    type Arguments;
    type Arg;
    type Keyword;
    type Alias;
    type Withitem;
    type MatchCase;
    type Pattern;
    type TypeIgnore;
}

#[derive(Copy, Clone, Debug)]
pub enum ArgType {
    PositionalOnly,
    Simple,
    /// The single vararg argument
    Vararg,
    KeywordOnly,
    KeywordArg,
}
pub trait SpecificArgVisitor<'a>: AstVisitor<'a> {
    fn visit_annotation(&mut self, ann: Self::Expr) -> Result<(), Self::Err>;
    fn visit_default(&mut self, ann: Self::Expr) -> Result<(), Self::Err>;
    fn visit_type_commnt(&mut self, cmt: &'a str) -> Result<(), Self::Err>;
    fn finish(self, span: Span) -> Result<Self::Arg>;
} 
pub trait ArgumentsVisitor<'a>: AstVisitor<'a> {
    type Positional: SpecificArgVisitor<'a>;
    fn visit_positional_arg(
        &mut self,
        positional_only: bool,
        name: Self::Ident
    ) -> Result<Self::Positional, Self::Err>;
    type Vararg: SpecificArgVisitor<'a>;
    fn visit_vararg(
        &mut self,
        name: Self::Ident
    ) -> Result<Self::Vararg, Self::Err>;
    type KeywordArg: SpecificArgVisitor<'a>;
    fn visit_keyword_arg(
        &mut self,
        keyword_only: bool,
        name: Self::Ident,
    ) -> Result<Self::KeywordArg, Self::Err>;
    type KeywordVararg: SpecificArgVisitor<'a>;
    fn visit_keyword_vararg(&mut self, name: Self::Ident) -> Result<Self::KeywordVararg, Self::Err>;
    fn finish(&self, span: Span) -> Result<Self::Arguments, Self::Err>;
}

pub trait FunctionDefVisitor<'a>: AstVisitor<'a> {
    fn visit_body_stmt(&mut self, stmt: Self::Stmt) -> Self::Body;
    fn visit_type_comment(&mut self, cmt: &str) -> Result<(), Self::Err>;
    fn visit_return(&mut self, rtn: Self::Expr) -> Result<(), Self::Err>;
    fn finish(self, span: Span) -> Result<<Self as AstVisitor<'a>>::Stmt, Self::Err>;
}
pub trait ClassDefVisitor<'a>: AstVisitor<'a> {
    fn visit_body_stmt(&mut self, stmt: Self::Stmt) -> Result<(), Self::Err>;
    fn visit_base(&mut self, base: Self::Expr) -> Result<(), Self::Err>;
    fn visit_keyword(&mut self, keyword: Self::Keyword) -> Result<(), Self::Err>;
    fn finish(self, span: Span) -> Result<Self::Stmt, Self::Err>;
}
pub trait DecoratorVisitor<'a>: AstVisitor<'a> {
    type List;
    fn visit_decorator(&mut self, expr: Self::Expr) -> Result<(), Self::Err>;
    fn finish(self) -> Result<Self::Decorators, Self::Err>;
}
/// Visits a 'simple' assignment
pub trait SimpleAssignVisitor<'a>: AstVisitor<'a> {
    fn visit_target(&mut self, target: Self::Expr) -> Result<(), Self::Err>;
    fn visit_value(&mut self, target: Self::Expr);
    fn visit_type_comment(&mut self, cmt: &str) -> Result<(), Self::Err>;
    fn finish(self) -> Result<Self::Stmt, Self::Err>;
}

pub trait DeleteVisitor<'a> {
    fn visit_target(&mut self, target: Self::Expr) -> Result<(), Self::Err>;   
    fn finish(self) -> Result<Self::Stmt, Self::Err>;
}
pub trait StatementVisitor<'a>: AstVisitor<'a> {
    type FuncDef: FunctionDefVisitor<'a> + AstVisitor<'a, Stmt=Self::Stmt>;
    type AsyncFuncDef: FunctionDefVisitor<'a> + AstVisitor<'a, Stmt=Self::Stmt>;
    type Decorators: DecoratorVisitor<'a, List=Self::DecoratorList>;
    type DecoratorList;
    fn visit_decorators(&mut self) -> Self::Decorators;
    type ArgumentVisitor: ArgumentsVisitor<'a>;
    fn visit_arguments(&mut self) -> Self::ArgumentVisitor;
    fn visit_stmt_function_def(
        &mut self,
        decorators: Option<Self::DecoratorList>,
        args: Self::Arguments,
        name: Self::Ident
    ) -> Self::FuncDef ;
    fn visit_stmt_async_function_def(
        &mut self,
        decorators: Option<Self::DecoratorList>,
        args: Self::Arguments,
        name: Self::Ident
    ) -> Self::AsyncFuncDef ;
    type ClassDef: ClassDefVisitor<'a>;
    fn visit_stmt_class_def(
            &mut self,
            span: Span,
            name: Self::Ident,
            decorators: Option<Self::DecoratorList>,
    ) -> Self::ClassDef ;
    fn visit_stmt_return(
            &mut self,
            span: Span,
            value: Option<Self::Expr>,
    ) -> Self::Stmt ;
    type Delete: StatementVisitor<'a>;
    fn visit_stmt_delete(
            &mut self,
            span: Span,
    ) -> Self::Delete ;
    type SimpleAssign: SimpleAssignVisitor<'a>;
    fn visit_stmt_assign(
            &mut self,
            span: Span,
    ) -> Self::Stmt ;
    fn visit_stmt_aug_assign(
            &mut self,
            span: Span,
            target: Self::Expr,
            op: Operator,
            value: Self::Expr,
    ) -> Self::Stmt ;
    fn visit_stmt_ann_assign(
            &mut self,
            span: Span,
            target: Self::Expr,
            annotation: Self::Expr,
            value: Option<Self::Expr>,
            simple: i32,
    ) -> Self::Stmt ;
    fn visit_stmt_for(
            &mut self,
            span: Span,
            target: Self::Expr,
            iter: Self::Expr,
            body: impl Iterator<Item=Self::Stmt>,
            orelse: impl Iterator<Item=Self::Stmt>,
            type_comment: Option<&'a str>,
    ) -> Self::Stmt ;
    fn visit_stmt_async_for(
            &mut self,
            span: Span,
            target: Self::Expr,
            iter: Self::Expr,
            body: impl Iterator<Item=Self::Stmt>,
            orelse: impl Iterator<Item=Self::Stmt>,
            type_comment: Option<&'a str>,
    ) -> Self::Stmt ;
    fn visit_stmt_while(
            &mut self,
            span: Span,
            test: Self::Expr,
            body: impl Iterator<Item=Self::Stmt>,
            orelse: impl Iterator<Item=Self::Stmt>,
    ) -> Self::Stmt ;
    fn visit_stmt_if(
            &mut self,
            span: Span,
            test: Self::Expr,
            body: impl Iterator<Item=Self::Stmt>,
            orelse: impl Iterator<Item=Self::Stmt>,
    ) -> Self::Stmt ;
    fn visit_stmt_with(
            &mut self,
            span: Span,
            items: impl Iterator<Item=Self::Withitem>,
            body: impl Iterator<Item=Self::Stmt>,
            type_comment: Option<&'a str>,
    ) -> Self::Stmt ;
    fn visit_stmt_async_with(
            &mut self,
            span: Span,
            items: impl Iterator<Item=Self::Withitem>,
            body: impl Iterator<Item=Self::Stmt>,
            type_comment: Option<&'a str>,
    ) -> Self::Stmt ;
    fn visit_stmt_match(
            &mut self,
            span: Span,
            subject: Self::Expr,
            cases: impl Iterator<Item=Self::MatchCase>,
    ) -> Self::Stmt ;
    fn visit_stmt_raise(
            &mut self,
            span: Span,
            exc: Option<Self::Expr>,
            cause: Option<Self::Expr>,
    ) -> Self::Stmt ;
    fn visit_stmt_try(
            &mut self,
            span: Span,
            body: impl Iterator<Item=Self::Stmt>,
            handlers: impl Iterator<Item=Self::Excepthandler>,
            orelse: impl Iterator<Item=Self::Stmt>,
            finalbody: impl Iterator<Item=Self::Stmt>,
    ) -> Self::Stmt ;
    fn visit_stmt_assert(
            &mut self,
            span: Span,
            test: Self::Expr,
            msg: Option<Self::Expr>,
    ) -> Self::Stmt ;
    fn visit_stmt_import(
            &mut self,
            span: Span,
            names: impl Iterator<Item=Self::Alias>,
    ) -> Self::Stmt ;
    fn visit_stmt_import_from(
            &mut self,
            span: Span,
            module: Option<Self::Ident>,
            names: impl Iterator<Item=Self::Alias>,
            level: Option<i32>,
    ) -> Self::Stmt ;
    fn visit_stmt_global(
            &mut self,
            span: Span,
            names: impl Iterator<Item=Self::Ident>,
    ) -> Self::Stmt ;
    fn visit_stmt_nonlocal(
            &mut self,
            span: Span,
            names: impl Iterator<Item=Self::Ident>,
    ) -> Self::Stmt ;
    fn visit_stmt_expr(
            &mut self,
            span: Span,
            value: Self::Expr,
    ) -> Self::Stmt ;
    fn visit_stmt_pass(
            &mut self,
            span: Span,
    ) -> Self::Stmt ;
    fn visit_stmt_break(
            &mut self,
            span: Span,
    ) -> Self::Stmt ;
    fn visit_stmt_continue(
            &mut self,
            span: Span,
    ) -> Self::Stmt ;
}

pub trait ExpressionVisitor<'a>: AstVisitor<'a> {
    fn visit_expr_bool_op(
            &mut self,
            span: Span,
            op: Boolop,
            values: impl Iterator<Item=Self::Expr>,
    ) -> Self::Expr ;
    fn visit_expr_named_expr(
            &mut self,
            span: Span,
            target: Self::Expr,
            value: Self::Expr,
    ) -> Self::Expr ;
    fn visit_expr_bin_op(
            &mut self,
            span: Span,
            left: Self::Expr,
            op: Operator,
            right: Self::Expr,
    ) -> Self::Expr ;
    fn visit_expr_unary_op(
            &mut self,
            span: Span,
            op: Unaryop,
            operand: Self::Expr,
    ) -> Self::Expr ;
    fn visit_expr_lambda(
            &mut self,
            span: Span,
            args: Self::Arguments,
            body: Self::Expr,
    ) -> Self::Expr ;
    fn visit_expr_if_exp(
            &mut self,
            span: Span,
            test: Self::Expr,
            body: Self::Expr,
            orelse: Self::Expr,
    ) -> Self::Expr ;
    fn visit_expr_dict(
            &mut self,
            span: Span,
            elements: impl Iterator<Item=(Self::Expr, Self::Expr)>,
    ) -> Self::Expr ;
    fn visit_expr_set(
            &mut self,
            span: Span,
            elts: impl Iterator<Item=Self::Expr>,
    ) -> Self::Expr ;
    fn visit_expr_list_comp(
            &mut self,
            span: Span,
            elt: Self::Expr,
            generators: impl Iterator<Item=Self::Comprehension>,
    ) -> Self::Expr ;
    fn visit_expr_set_comp(
            &mut self,
            span: Span,
            elt: Self::Expr,
            generators: impl Iterator<Item=Self::Comprehension>,
    ) -> Self::Expr ;
    fn visit_expr_dict_comp(
            &mut self,
            span: Span,
            key: Self::Expr,
            value: Self::Expr,
            generators: impl Iterator<Item=Self::Comprehension>,
    ) -> Self::Expr ;
    fn visit_expr_generator_exp(
            &mut self,
            span: Span,
            elt: Self::Expr,
            generators: impl Iterator<Item=Self::Comprehension>,
    ) -> Self::Expr ;
    fn visit_expr_await(
            &mut self,
            span: Span,
            value: Self::Expr,
    ) -> Self::Expr ;
    fn visit_expr_yield(
            &mut self,
            span: Span,
            value: Option<Self::Expr>,
    ) -> Self::Expr ;
    fn visit_expr_yield_from(
            &mut self,
            span: Span,
            value: Self::Expr,
    ) -> Self::Expr ;
    fn visit_expr_compare(
            &mut self,
            span: Span,
            left: Self::Expr,
            ops: impl Iterator<Item=Cmpop>,
            comparators: impl Iterator<Item=Self::Expr>,
    ) -> Self::Expr ;
    fn visit_expr_call(
            &mut self,
            span: Span,
            func: Self::Expr,
            args: impl Iterator<Item=Self::Expr>,
            keywords: impl Iterator<Item=Self::Keyword>,
    ) -> Self::Expr ;
    fn visit_expr_formatted_value(
            &mut self,
            span: Span,
            value: Self::Expr,
            conversion: Option<i32>,
            format_spec: Option<Self::Expr>,
    ) -> Self::Expr ;
    fn visit_expr_joined_str(
            &mut self,
            span: Span,
            values: impl Iterator<Item=Self::Expr>,
    ) -> Self::Expr ;
    fn visit_expr_constant(
            &mut self,
            span: Span,
            value: Self::Constant,
            kind: Option<&'a str>,
    ) -> Self::Expr ;
    fn visit_expr_attribute(
            &mut self,
            span: Span,
            value: Self::Expr,
            attr: Self::Ident,
            ctx: ExprContext,
    ) -> Self::Expr ;
    fn visit_expr_subscript(
            &mut self,
            span: Span,
            value: Self::Expr,
            slice: Self::Expr,
            ctx: ExprContext,
    ) -> Self::Expr ;
    fn visit_expr_starred(
            &mut self,
            span: Span,
            value: Self::Expr,
            ctx: ExprContext,
    ) -> Self::Expr ;
    fn visit_expr_name(
            &mut self,
            span: Span,
            id: Self::Ident,
            ctx: ExprContext,
    ) -> Self::Expr ;
    fn visit_expr_list(
            &mut self,
            span: Span,
            elts: impl Iterator<Item=Self::Expr>,
            ctx: ExprContext,
    ) -> Self::Expr ;
    fn visit_expr_tuple(
            &mut self,
            span: Span,
            elts: impl Iterator<Item=Self::Expr>,
            ctx: ExprContext,
    ) -> Self::Expr ;
    fn visit_expr_slice(
            &mut self,
            span: Span,
            lower: Option<Self::Expr>,
            upper: Option<Self::Expr>,
            step: Option<Self::Expr>,
    ) -> Self::Expr ;
}

pub trait ModVisitor<'a>: AstVisitor<'a> {
    type Module: ModBodyVisitor<'a>;
    type Interactive: ModBodyVisitor<'a>;
    fn visit_mod_module(
            &mut self,
    ) -> Self::Module;
    fn visit_mod_interactive(
            &mut self,
    ) -> Self::Interactive;
    fn visit_mod_expression(
            &mut self,
            body: Self::Expr,
    ) -> Result<Self::Mod, Self::Err>;
}
pub trait ModBodyVisitor<'a>: AstVisitor<'a> {
    fn visit_body_stmt(&mut self, stmt: Self::Stmt) -> Result<(), Self::Err>;
    fn visit_type_comment(&mut self, cmt: &'a str) -> Result<(), Self::Err>;
    fn finish(self) -> Result<Self::Mod, Self::Err>;
}

pub trait PatternVisitor<'a>: AstVisitor<'a> {
    fn visit_pattern_match_value(
            &mut self,
            span: Span,
            value: Self::Expr,
    ) -> Result<Self::Pattern, Self::Err>;
    fn visit_pattern_match_singleton(
            &mut self,
            span: Span,
            value: Self::Constant,
    ) -> Self::Pattern ;
    fn visit_pattern_match_sequence(
            &mut self,
            span: Span,
            patterns: impl Iterator<Item=Self::Pattern>,
    ) -> Self::Pattern ;
    fn visit_pattern_match_mapping(
            &mut self,
            span: Span,
            keys: impl Iterator<Item=Self::Expr>,
            patterns: impl Iterator<Item=Self::Pattern>,
            rest: Option<Self::Ident>,
    ) -> Self::Pattern ;
    fn visit_pattern_match_class(
            &mut self,
            span: Span,
            cls: Self::Expr,
            patterns: impl Iterator<Item=Self::Pattern>,
            kwd_attrs: impl Iterator<Item=Self::Ident>,
            kwd_patterns: impl Iterator<Item=Self::Pattern>,
    ) -> Self::Pattern ;
    fn visit_pattern_match_star(
            &mut self,
            span: Span,
            name: Option<Self::Ident>,
    ) -> Self::Pattern ;
    fn visit_pattern_match_as(
            &mut self,
            span: Span,
            pattern: Option<Self::Pattern>,
            name: Option<Self::Ident>,
    ) -> Self::Pattern ;
    fn visit_pattern_match_or(
            &mut self,
            span: Span,
            patterns: impl Iterator<Item=Self::Pattern>,
    ) -> Self::Pattern ;
}
