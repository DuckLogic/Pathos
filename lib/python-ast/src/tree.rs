//! A in-memory representation of the AST
//!
//! This is automatically generated from the ASDL file

use educe::Educe;
use std::hash::Hash;
use std::fmt::{self, Debug, Formatter, Display};
use std::num::NonZeroU32;

#[cfg(feature = "serialize")]
use serde_with::{serde_as};
#[cfg(feature = "serialize")]
use serde::{Serializer, Serialize};
#[cfg(feature = "serialize")]
use std::cmp::Ordering;


use pathos::ast::{Ident, Span, Spanned, AstNode};

use super::constants::Constant;
use crate::ExprPrec;

/*
 * Original file was automatically generated by asdl/rust.py.
 * However, it has been seriously revised since then.
 */


#[derive(Educe, Debug, Clone)]
#[educe(PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serialize", derive(Serialize))]
#[cfg_attr(feature = "serialize", serde(tag = "type", rename = "mod"))]
pub enum PythonAst<'a> {
    Module {
        body: &'a [Stmt<'a>],
        type_ignores: &'a [TypeIgnore<'a>],
    },
    Interactive {
        body: &'a [Stmt<'a>],
    },
    Expression {
        body: Expr<'a>,
    },
    FunctionType {
        #[cfg_attr(feature = "serialize", serde(rename = "argtypes"))]
        arg_types: &'a [Expr<'a>],
        returns: Expr<'a>,
    },
}
impl<'a> PythonAst<'a> {
    #[inline]
    pub fn as_expression(&self) -> Option<Expr<'a>> {
        match *self {
            PythonAst::Expression { body } => Some(body),
            _ => None
        }
    }
}
/// A reference to a statement
pub type Stmt<'a> = &'a StmtKind<'a>;

#[cfg_attr(feature = "serialize", serde_as)]
#[derive(Educe, Debug, Clone)]
#[educe(PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serialize", derive(Serialize))]
#[cfg_attr(feature = "serialize", serde(tag = "type"))]
pub enum StmtKind<'a> {
    FunctionDef {
        /// The span of the source
        #[educe(Hash(ignore))]
        #[educe(PartialEq(ignore))]
        span: Span,
        name: Ident<'a>,
        args: &'a Arguments<'a>,
        body: &'a [Stmt<'a>],
        decorator_list: &'a [Expr<'a>],
        returns: Option<Expr<'a>>,
        #[cfg_attr(feature = "serialize", serde(skip_serializing_if = "Option::is_none"))]
        type_comment: Option<&'a str>,
    },
    /*
     * TODO: Consider merging with FunctionDef
     * NOTE: This would make serialization hard :(
     */
    AsyncFunctionDef {
        /// The span of the source
        #[educe(Hash(ignore))]
        #[educe(PartialEq(ignore))]
        span: Span,
        name: Ident<'a>,
        args: &'a Arguments<'a>,
        body: &'a [Stmt<'a>],
        decorator_list: &'a [Expr<'a>],
        returns: Option<Expr<'a>>,
        #[cfg_attr(feature = "serialize", serde(skip_serializing_if = "Option::is_none"))]
        type_comment: Option<&'a str>,
    },
    ClassDef {
        /// The span of the source
        #[educe(Hash(ignore))]
        #[educe(PartialEq(ignore))]
        span: Span,
        name: Ident<'a>,
        bases: &'a [Expr<'a>],
        keywords: &'a [Keyword<'a>],
        body: &'a [Stmt<'a>],
        decorator_list: &'a [Expr<'a>],
    },
    Return {
        /// The span of the source
        #[educe(Hash(ignore))]
        #[educe(PartialEq(ignore))]
        span: Span,
        value: Option<Expr<'a>>,
    },
    Delete {
        /// The span of the source
        #[educe(Hash(ignore))]
        #[educe(PartialEq(ignore))]
        span: Span,
        targets: &'a [Expr<'a>],
    },
    Assign {
        /// The span of the source
        #[educe(Hash(ignore))]
        #[educe(PartialEq(ignore))]
        span: Span,
        targets: &'a [Expr<'a>],
        value: Expr<'a>,
        #[cfg_attr(feature = "serialize", serde(skip_serializing_if = "Option::is_none"))]
        type_comment: Option<&'a str>,
    },
    AugAssign {
        /// The span of the source
        #[educe(Hash(ignore))]
        #[educe(PartialEq(ignore))]
        span: Span,
        target: Expr<'a>,
        op: Operator,
        value: Expr<'a>,
    },
    AnnAssign {
        /// The span of the source
        #[educe(Hash(ignore))]
        #[educe(PartialEq(ignore))]
        span: Span,
        target: Expr<'a>,
        annotation: Expr<'a>,
        value: Option<Expr<'a>>,
        simple: bool,
    },
    For {
        /// The span of the source
        #[educe(Hash(ignore))]
        #[educe(PartialEq(ignore))]
        span: Span,
        target: Expr<'a>,
        iter: Expr<'a>,
        body: &'a [Stmt<'a>],
        #[cfg_attr(feature = "serialize", serde(rename = "orelse"))]
        or_else: &'a [Stmt<'a>],
        #[cfg_attr(feature = "serialize", serde(skip_serializing_if = "Option::is_none"))]
        type_comment: Option<&'a str>,
    },
    AsyncFor {
        /// The span of the source
        #[educe(Hash(ignore))]
        #[educe(PartialEq(ignore))]
        span: Span,
        target: Expr<'a>,
        iter: Expr<'a>,
        body: &'a [Stmt<'a>],
        #[cfg_attr(feature = "serialize", serde(rename = "orelse"))]
        or_else: &'a [Stmt<'a>],
        #[cfg_attr(feature = "serialize", serde(skip_serializing_if = "Option::is_none"))]
        type_comment: Option<&'a str>,
    },
    While {
        /// The span of the source
        #[educe(Hash(ignore))]
        #[educe(PartialEq(ignore))]
        span: Span,
        test: Expr<'a>,
        body: &'a [Stmt<'a>],
        #[cfg_attr(feature = "serialize", serde(rename = "orelse"))]
        or_else: &'a [Stmt<'a>],
    },
    If {
        /// The span of the source
        #[educe(Hash(ignore))]
        #[educe(PartialEq(ignore))]
        span: Span,
        test: Expr<'a>,
        body: &'a [Stmt<'a>],
        #[cfg_attr(feature = "serialize", serde(rename = "orelse"))]
        or_else: &'a [Stmt<'a>],
    },
    With {
        /// The span of the source
        #[educe(Hash(ignore))]
        #[educe(PartialEq(ignore))]
        span: Span,
        items: &'a [WithItem<'a>],
        body: &'a [Stmt<'a>],
        #[cfg_attr(feature = "serialize", serde(skip_serializing_if = "Option::is_none"))]
        type_comment: Option<&'a str>,
    },
    AsyncWith {
        /// The span of the source
        #[educe(Hash(ignore))]
        #[educe(PartialEq(ignore))]
        span: Span,
        items: &'a [WithItem<'a>],
        body: &'a [Stmt<'a>],
        #[cfg_attr(feature = "serialize", serde(skip_serializing_if = "Option::is_none"))]
        type_comment: Option<&'a str>,
    },
    Match {
        /// The span of the source
        #[educe(Hash(ignore))]
        #[educe(PartialEq(ignore))]
        span: Span,
        subject: Expr<'a>,
        cases: &'a [MatchCase<'a>],
    },
    Raise {
        /// The span of the source
        #[educe(Hash(ignore))]
        #[educe(PartialEq(ignore))]
        span: Span,
        exc: Option<Expr<'a>>,
        cause: Option<Expr<'a>>,
    },
    Try {
        /// The span of the source
        #[educe(Hash(ignore))]
        #[educe(PartialEq(ignore))]
        span: Span,
        body: &'a [Stmt<'a>],
        handlers: &'a [ExceptHandler<'a>],
        #[cfg_attr(feature = "serialize", serde(rename = "orelse"))]
        or_else: &'a [Stmt<'a>],
        #[cfg_attr(feature = "serialize", serde(rename = "finalbody"))]
        final_body: &'a [Stmt<'a>],
    },
    Assert {
        /// The span of the source
        #[educe(Hash(ignore))]
        #[educe(PartialEq(ignore))]
        span: Span,
        test: Expr<'a>,
        msg: Option<Expr<'a>>,
    },
    Import {
        /// The span of the source
        #[educe(Hash(ignore))]
        #[educe(PartialEq(ignore))]
        span: Span,
        names: &'a [Alias<ModulePath<'a>>],
    },
    ImportFrom {
        /// The span of the source
        #[educe(Hash(ignore))]
        #[educe(PartialEq(ignore))]
        span: Span,
        #[cfg_attr(feature = "serialize", serde(flatten))]
        module: RelativeModule<'a>,
        names: &'a [Alias<Ident<'a>>],
    },
    Global {
        /// The span of the source
        #[educe(Hash(ignore))]
        #[educe(PartialEq(ignore))]
        span: Span,
        names: &'a [Ident<'a>],
    },
    #[cfg_attr(feature = "serialize", serde(rename = "Nonlocal"))]
    NonLocal {
        /// The span of the source
        #[educe(Hash(ignore))]
        #[educe(PartialEq(ignore))]
        span: Span,
        names: &'a [Ident<'a>],
    },
    Expr {
        /// The span of the source
        #[educe(Hash(ignore))]
        #[educe(PartialEq(ignore))]
        span: Span,
        value: Expr<'a>,
    },
    Pass {
        /// The span of the source
        #[educe(Hash(ignore))]
        #[educe(PartialEq(ignore))]
        span: Span,
    },
    Break {
        /// The span of the source
        #[educe(Hash(ignore))]
        #[educe(PartialEq(ignore))]
        span: Span,
    },
    Continue {
        /// The span of the source
        #[educe(Hash(ignore))]
        #[educe(PartialEq(ignore))]
        span: Span,
    },
}
impl<'a> ExprKind<'a> {
    /// Return if the expression a 'target' expression
    ///
    /// Target expressions are a restricted subset of regular expressions,
    /// and are often handled differently in the parser.
    ///
    /// See docs for the official rules on targets:
    /// <https://docs.python.org/3.10/reference/simple_stmts.html#assignment-statements>
    #[inline]
    pub fn is_target(&self) -> bool {
        self.is_augmented_assignment_target() ||
            matches!(self, ExprKind::Starred { .. } | ExprKind::List { .. } | ExprKind::Tuple { .. })
    }
    /// Return if the expression is an 'augmented assignment target'
    ///
    /// This is a special-case of targets,
    /// so it can only return true if [ExprKind::is_target] is also true
    ///
    /// See docs for the official rules on these expressions:
    /// <https://docs.python.org/3.11/reference/simple_stmts.html#augmented-assignment-statements>
    #[inline]
    pub fn is_augmented_assignment_target(&self) -> bool {
        matches!(self, ExprKind::Name { .. } | ExprKind::Attribute { .. } | ExprKind::Subscript { .. })
    }
}
impl<'a> AstNode for StmtKind<'a> {}
impl<'a> Spanned for StmtKind<'a> {
    fn span(&self) -> Span {
        match *self {
            StmtKind::FunctionDef { span, .. } |
            StmtKind::AsyncFunctionDef { span, .. } |
            StmtKind::ClassDef { span, .. } |
            StmtKind::Return { span, .. } |
            StmtKind::Delete { span, .. } |
            StmtKind::Assign { span, .. } |
            StmtKind::AugAssign { span, .. } |
            StmtKind::AnnAssign { span, .. } |
            StmtKind::For { span, .. } |
            StmtKind::AsyncFor { span, .. } |
            StmtKind::While { span, .. } |
            StmtKind::If { span, .. } |
            StmtKind::With { span, .. } |
            StmtKind::AsyncWith { span, .. } |
            StmtKind::Match { span, .. } |
            StmtKind::Raise { span, .. } |
            StmtKind::Try { span, .. } |
            StmtKind::Assert { span, .. } |
            StmtKind::Import { span, .. } |
            StmtKind::ImportFrom { span, .. } |
            StmtKind::Global { span, .. } |
            StmtKind::NonLocal { span, .. } |
            StmtKind::Expr { span, .. } |
            StmtKind::Pass { span, .. } |
            StmtKind::Break { span, .. } |
            StmtKind::Continue { span, .. } => span,
        }
    }
}

/// A reference to an expression
pub type Expr<'a> = &'a ExprKind<'a>;

/// The type of a python expression
#[cfg_attr(feature = "serialize", serde_as)]
#[derive(Educe, Debug, Clone)]
#[educe(PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serialize", derive(Serialize))]
pub enum ExprKind<'a> {
    BoolOp {
        /// The span of the source
        #[educe(Hash(ignore))]
        #[educe(PartialEq(ignore))]
        span: Span,
        op: BoolOp,
        values: &'a [Expr<'a>],
    },
    NamedExpr {
        /// The span of the source
        #[educe(Hash(ignore))]
        #[educe(PartialEq(ignore))]
        span: Span,
        target: Expr<'a>,
        value: Expr<'a>,
    },
    BinOp {
        /// The span of the source
        #[educe(Hash(ignore))]
        #[educe(PartialEq(ignore))]
        span: Span,
        left: Expr<'a>,
        op: Operator,
        right: Expr<'a>,
    },
    UnaryOp {
        /// The span of the source
        #[educe(Hash(ignore))]
        #[educe(PartialEq(ignore))]
        span: Span,
        op: UnaryOp,
        operand: Expr<'a>,
    },
    Lambda {
        /// The span of the source
        #[educe(Hash(ignore))]
        #[educe(PartialEq(ignore))]
        span: Span,
        args: &'a Arguments<'a>,
        body: Expr<'a>,
    },
    IfExp {
        /// The span of the source
        #[educe(Hash(ignore))]
        #[educe(PartialEq(ignore))]
        span: Span,
        test: Expr<'a>,
        body: Expr<'a>,
        #[cfg_attr(feature = "serialize", serde(rename = "orelse"))]
        or_else: Expr<'a>,
    },
    Dict {
        /// The span of the source
        #[educe(Hash(ignore))]
        #[educe(PartialEq(ignore))]
        span: Span,
        #[cfg_attr(feature = "serialize", serde(flatten, serialize_with = "serialize_dict_elements_as_pair"))]
        elements: &'a [(Expr<'a>, Expr<'a>)],
    },
    Set {
        /// The span of the source
        #[educe(Hash(ignore))]
        #[educe(PartialEq(ignore))]
        span: Span,
        #[cfg_attr(feature = "serialize", serde(rename = "elts"))]
        elements: &'a [Expr<'a>],
    },
    ListComp {
        /// The span of the source
        #[educe(Hash(ignore))]
        #[educe(PartialEq(ignore))]
        span: Span,
        elt: Expr<'a>,
        generators: &'a [Comprehension<'a>],
    },
    SetComp {
        /// The span of the source
        #[educe(Hash(ignore))]
        #[educe(PartialEq(ignore))]
        span: Span,
        elt: Expr<'a>,
        generators: &'a [Comprehension<'a>],
    },
    DictComp {
        /// The span of the source
        #[educe(Hash(ignore))]
        #[educe(PartialEq(ignore))]
        span: Span,
        key: Expr<'a>,
        value: Expr<'a>,
        generators: &'a [Comprehension<'a>],
    },
    GeneratorExp {
        /// The span of the source
        #[educe(Hash(ignore))]
        #[educe(PartialEq(ignore))]
        span: Span,
        elt: Expr<'a>,
        generators: &'a [Comprehension<'a>],
    },
    Await {
        /// The span of the source
        #[educe(Hash(ignore))]
        #[educe(PartialEq(ignore))]
        span: Span,
        value: Expr<'a>,
    },
    Yield {
        /// The span of the source
        #[educe(Hash(ignore))]
        #[educe(PartialEq(ignore))]
        span: Span,
        value: Option<Expr<'a>>,

    },
    YieldFrom {
        /// The span of the source
        #[educe(Hash(ignore))]
        #[educe(PartialEq(ignore))]
        span: Span,
        value: Expr<'a>,

    },
    Compare {
        /// The span of the source
        #[educe(Hash(ignore))]
        #[educe(PartialEq(ignore))]
        span: Span,
        left: Expr<'a>,
        comparators: &'a [(ComparisonOp, Expr<'a>)],
    },
    Call {
        /// The span of the source
        #[educe(Hash(ignore))]
        #[educe(PartialEq(ignore))]
        span: Span,
        func: Expr<'a>,
        #[serde(flatten)]
        args: CallArgs<'a>
    },
    FormattedValue {
        /// The span of the source
        #[educe(Hash(ignore))]
        #[educe(PartialEq(ignore))]
        span: Span,
        value: Expr<'a>,
        conversion: Option<char>,
        format_spec: Option<Expr<'a>>,
    },
    JoinedStr {
        /// The span of the source
        #[educe(Hash(ignore))]
        #[educe(PartialEq(ignore))]
        span: Span,
        values: &'a [Expr<'a>],
    },
    Constant {
        /// The span of the source
        #[educe(Hash(ignore))]
        #[educe(PartialEq(ignore))]
        span: Span,
        value: Constant<'a>,
        kind: Option<&'a str>,
    },
    Attribute {
        /// The span of the source
        #[educe(Hash(ignore))]
        #[educe(PartialEq(ignore))]
        span: Span,
        value: Expr<'a>,
        attr: Ident<'a>,
        ctx: ExprContext,
    },
    Subscript {
        /// The span of the source
        #[educe(Hash(ignore))]
        #[educe(PartialEq(ignore))]
        span: Span,
        index: Expr<'a>,
        slice: Expr<'a>,
        ctx: ExprContext,
    },
    Starred {
        /// The span of the source
        #[educe(Hash(ignore))]
        #[educe(PartialEq(ignore))]
        span: Span,
        value: Expr<'a>,
        ctx: ExprContext,
    },
    Name {
        /// The span of the source
        #[educe(Hash(ignore))]
        #[educe(PartialEq(ignore))]
        span: Span,
        id: Ident<'a>,
        ctx: ExprContext,
    },
    List {
        /// The span of the source
        #[educe(Hash(ignore))]
        #[educe(PartialEq(ignore))]
        span: Span,
        elts: &'a [Expr<'a>],
        ctx: ExprContext,
    },
    Tuple {
        /// The span of the source
        #[educe(Hash(ignore))]
        #[educe(PartialEq(ignore))]
        span: Span,
        elts: &'a [Expr<'a>],
        ctx: ExprContext,
    },
    Slice {
        /// The span of the source
        #[educe(Hash(ignore))]
        #[educe(PartialEq(ignore))]
        span: Span,
        lower: Option<Expr<'a>>,
        upper: Option<Expr<'a>>,
        step: Option<Expr<'a>>,
    },
}
impl<'a> AstNode for ExprKind<'a> {}
impl<'a> Spanned for ExprKind<'a> {
    fn span(&self) -> Span {
        match *self {
            ExprKind::BoolOp { span, .. } |
            ExprKind::NamedExpr { span, .. } |
            ExprKind::BinOp { span, .. } |
            ExprKind::UnaryOp { span, .. } |
            ExprKind::Lambda { span, .. } |
            ExprKind::IfExp { span, .. } |
            ExprKind::Dict { span, .. } |
            ExprKind::Set { span, .. } |
            ExprKind::ListComp { span, .. } |
            ExprKind::SetComp { span, .. } |
            ExprKind::DictComp { span, .. } |
            ExprKind::GeneratorExp { span, .. } |
            ExprKind::Await { span, .. } |
            ExprKind::Yield { span, .. } |
            ExprKind::YieldFrom { span, .. } |
            ExprKind::Compare { span, .. } |
            ExprKind::Call { span, .. } |
            ExprKind::FormattedValue { span, .. } |
            ExprKind::JoinedStr { span, .. } |
            ExprKind::Constant { span, .. } |
            ExprKind::Attribute { span, .. } |
            ExprKind::Subscript { span, .. } |
            ExprKind::Starred { span, .. } |
            ExprKind::Name { span, .. } |
            ExprKind::List { span, .. } |
            ExprKind::Tuple { span, .. } |
            ExprKind::Slice { span, .. } => span,
        }
    }
}

#[cfg_attr(feature = "serialize", serde_as)]
#[derive(Educe, Debug, Clone)]
#[educe(PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serialize", derive(Serialize))]
pub struct CallArgs<'a> {
    #[educe(Hash(ignore))]
    #[educe(PartialEq(ignore))]
    #[serde(skip, default = "Span::dummy")]
    pub span: Span,
    pub args: &'a [Expr<'a>],
    pub keywords: &'a [Keyword<'a>],
    pub keyword_varargs: Option<Expr<'a>>
}
impl<'a> Spanned for CallArgs<'a> {
    #[inline]
    fn span(&self) -> Span {
        self.span
    }
}
impl<'a> AstNode for CallArgs<'a> {}

#[cfg(feature = "serialize")]
fn serialize_dict_elements_as_pair<'a, S: Serializer>(elements: &'a [(Expr<'a>, Expr<'a>)], ser: S) -> Result<S::Ok, S::Error> {
    use serde::ser::{SerializeStruct, SerializeSeq};
    struct KeysSerializer<'a>(&'a [(Expr<'a>, Expr<'a>)]);
    impl<'a> Serialize for KeysSerializer<'a> {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error> where
            S: Serializer {
            let mut seq = serializer.serialize_seq(Some(self.0.len()))?;
            for &(key, _) in self.0 {
                seq.serialize_element(&key)?;
            }
            seq.end()
        }
    }
    struct ValuesSerializer<'a>(&'a [(Expr<'a>, Expr<'a>)]);
    impl<'a> Serialize for ValuesSerializer<'a> {
        fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error> where
            S: Serializer {
            let mut seq = serializer.serialize_seq(Some(self.0.len()))?;
            for &(_, value) in self.0 {
                seq.serialize_element(&value)?;
            }
            seq.end()
        }
    }
    let keys = KeysSerializer(elements);
    let values = ValuesSerializer(elements);
    let mut ser = ser.serialize_struct("DictElements", 2)?;
    ser.serialize_field("keys", &keys)?;
    ser.serialize_field("values", &values)?;
    ser.end()
}

#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]
#[cfg_attr(feature = "serialize", derive(Serialize))]
pub enum ExprContext {
    Load,
    Store,
    Del,
}
impl Default for ExprContext {
    fn default() -> Self {
        ExprContext::Load
    }
}

#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]
#[cfg_attr(feature = "serialize", derive(Serialize))]
pub enum BoolOp {
    And,
    Or,
}
impl BoolOp {
    #[inline]
    pub fn precedence(self) -> crate::prec::ExprPrec {
        match self {
            BoolOp::And => ExprPrec::BooleanAnd,
            BoolOp::Or => ExprPrec::BooleanOr
        }
    }
}

#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]
#[cfg_attr(feature = "serialize", derive(Serialize))]
pub enum Operator {
    Add,
    Sub,
    Mult,
    MatMult,
    Div,
    Mod,
    Pow,
    LShift,
    RShift,
    BitOr,
    BitXor,
    BitAnd,
    FloorDiv,
}
impl Operator {
    #[inline]
    pub fn is_right_associative(&self) -> bool {
        matches!(*self, Operator::Pow)
    }
    #[inline]
    pub fn precedence(self) -> crate::prec::ExprPrec {
        match self {
            Operator::Add | Operator::Sub => ExprPrec::Term,
            Operator::Mult | Operator::MatMult |
            Operator::Div | Operator::Mod |
            Operator::FloorDiv => ExprPrec::Factor,
            Operator::Pow => ExprPrec::Exponentiation,
            Operator::LShift | Operator::RShift => ExprPrec::Shifts,
            Operator::BitOr => ExprPrec::BitwiseOr,
            Operator::BitXor => ExprPrec::BitwiseXor,
            Operator::BitAnd => ExprPrec::BitwiseAnd
        }
    }
}

#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]
#[cfg_attr(feature = "serialize", derive(Serialize))]
pub enum UnaryOp {
    Invert,
    Not,
    UAdd,
    USub,
}
impl UnaryOp {
    #[inline]
    pub fn precedence(self) -> ExprPrec {
        match self {
            UnaryOp::Invert |
            UnaryOp::Not |
            UnaryOp::UAdd |
            UnaryOp::USub => ExprPrec::Unary,
        }
    }
}

#[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]
#[cfg_attr(feature = "serialize", derive(Serialize))]
pub enum ComparisonOp {
    Eq,
    NotEq,
    Lt,
    LtE,
    Gt,
    GtE,
    Is,
    IsNot,
    In,
    NotIn,
}
impl ComparisonOp {
    #[inline]
    pub fn precedence(self) -> ExprPrec {
        match self {
            ComparisonOp::Eq |
            ComparisonOp::NotEq |
            ComparisonOp::Lt |
            ComparisonOp::LtE |
            ComparisonOp::Gt |
            ComparisonOp::GtE |
            ComparisonOp::Is |
            ComparisonOp::IsNot |
            ComparisonOp::In |
            ComparisonOp::NotIn => ExprPrec::Comparisons
        }
    }
}

#[derive(Educe, Debug, Clone)]
#[educe(PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serialize", derive(Serialize))]
#[cfg_attr(feature = "serialize", serde(rename = "comprehension"))]
pub struct Comprehension<'a> {
    pub target: Expr<'a>,
    pub iter: Expr<'a>,
    pub ifs: &'a [Expr<'a>],
    pub is_async: bool,
}
impl<'a> AstNode for Comprehension<'a> {}
impl<'a> Spanned for Comprehension<'a> {
    fn span(&self) -> Span {
        let start = self.target.span().start;
        let end = self.ifs.last().cloned().map_or_else(|| self.iter.span(), ExprKind::span).end;
        Span { start, end }
    }
}

#[derive(Educe, Debug, Clone)]
#[educe(PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serialize", derive(Serialize))]
pub struct ExceptHandler<'a> {
    /// The span of the source
    #[educe(Hash(ignore))]
    #[educe(PartialEq(ignore))]
    span: Span,
    ast_type: Option<Expr<'a>>,
    name: Option<Ident<'a>>,
    body: &'a [Stmt<'a>],
}
impl<'a> AstNode for ExceptHandler<'a> {}
impl<'a> Spanned for ExceptHandler<'a> {
    #[inline]
    fn span(&self) -> Span {
        self.span
    }
}
#[derive(Educe, Debug, Clone)]
#[educe(PartialEq, Eq, Hash)]
pub struct Arguments<'a> {
    pub positional_args: &'a [Arg<'a>],
    pub vararg: Option<&'a Arg<'a>>,
    pub keyword_args: &'a [Arg<'a>],
    pub keyword_vararg: Option<&'a Arg<'a>>,
    #[educe(Hash(ignore))]
    #[educe(PartialEq(ignore))]
    pub span: Span
}
impl<'a> Spanned for Arguments<'a> {
    #[inline]
    fn span(&self) -> Span {
        self.span
    }
}
impl<'a> AstNode for Arguments<'a> {}
#[cfg(feature = "serialize")]
impl<'a> Serialize for Arguments<'a> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error> where S: Serializer {
        use serde::ser::{SerializeStruct, SerializeSeq, Error};
        struct DefaultArgSerializer<'a> {
            args: &'a [Arg<'a>],
            positional: bool,
        }
        impl<'a> Serialize for DefaultArgSerializer<'a> {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error> where S: Serializer {
                if self.positional {
                    /*
                     * If we're positional, we strip out all the s
                     */
                    let start_index = self.args.iter()
                        .position(|arg| arg.default_value.is_some())
                        .unwrap_or(self.args.len());
                    let mut seq = serializer.serialize_seq(Some(self.args.len() - start_index))?;
                    for arg in &self.args[start_index..] {
                        seq.serialize_element(&arg.default_value)?;
                    }
                    seq.end()
                } else {
                    let mut seq = serializer.serialize_seq(Some(self.args.len()))?;
                    for arg in self.args {
                        seq.serialize_element(arg)?;
                    }
                    seq.end()
                }
            }
        }
        struct CompatArgSerializer<'k, 'a: 'k>(&'k Arg<'a>);
        impl<'k, 'a> Serialize for CompatArgSerializer<'k, 'a> {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error> where S: Serializer {
                let len = if self.0.type_comment.is_some() { 3usize } else { 2 };
                let mut ser = serializer.serialize_struct("arg", len)?;
                ser.serialize_field("arg", &self.0.name)?;
                ser.serialize_field("annotation", &self.0.annotation)?;
                if let Some(type_comment) = self.0.type_comment {
                    ser.serialize_field("type_comment", type_comment)?;
                }
                ser.end()
            }
        }
        struct SerializeArgs<'a> {
            args: &'a [Arg<'a>],
            desired_style: ArgumentStyle,
            /// A 'minimum' style to impose, restricting the range of allowed styles
            min_allowed_style: Option<ArgumentStyle>,
            /// A 'maximum' style to impose, restricting the range of styles allowed in the arguments array
            max_allowed_style: Option<ArgumentStyle>
        }
        impl<'a> Serialize for SerializeArgs<'a> {
            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error> where
                S: Serializer {
                let mut seq = serializer.serialize_seq(None)?;
                let mut last_style = None;
                for arg in self.args {
                    if let Some(last_serialized_style) = last_style {
                        if arg.style < last_serialized_style {
                            // Not in order
                            return Err(S::Error::custom(format_args!(
                                "Invalid ordering: Expected {:?} arg to be after all {:?} args",
                                arg.style, last_serialized_style
                            )));
                        }
                    }
                    match arg.style.cmp(&self.desired_style) {
                        Ordering::Less => {
                            if let Some(min) = self.min_allowed_style {
                                if arg.style < min {
                                    return Err(S::Error::custom(format_args!(
                                        "Arg style {:?} is not allowed (must be >= {:?})",
                                        arg.style, min
                                    )))
                                }
                            }
                            last_style = Some(arg.style);
                        },
                        Ordering::Equal => {
                            last_style = Some(arg.style);
                            seq.serialize_element(&CompatArgSerializer(arg))?;
                        }
                        Ordering::Greater => {
                            /*
                             * Since we expect everything to be in order (and that later serializers will check this),
                             * then it's fine if we break here.
                             * Make sure the 'arg.style < max_allowed_style' (if we have one)
                             * This is needed to make sure we don't have nonsense like keyword-only
                             * arguments ending up in the positional argument array.
                             */
                            if let Some(max) = self.max_allowed_style {
                                if arg.style > max {
                                    return Err(S::Error::custom(format_args!(
                                        "Arg style {:?} is not allowed (must be <= {:?})",
                                        arg.style, max
                                    )));
                                }
                            }
                            break
                        }
                    }
                }
                seq.end()
            }
        }
        let mut ser = serializer.serialize_struct("arguments", 7)?;
        ser.serialize_field("posonlyargs", &SerializeArgs {
            args: self.positional_args,
            desired_style: ArgumentStyle::PositionalOnly,
            min_allowed_style: None,
            max_allowed_style: None // As long as we're ordered, we can check the limits later
        })?;
        ser.serialize_field("args", &SerializeArgs {
            args: self.positional_args,
            desired_style: ArgumentStyle::Positional,
            min_allowed_style: None,
            max_allowed_style: Some(ArgumentStyle::Positional)
        })?;
        ser.serialize_field("vararg", &self.vararg)?;
        ser.serialize_field("kwonlyargs", &SerializeArgs {
            args: self.keyword_args,
            min_allowed_style: Some(ArgumentStyle::Keyword),
            max_allowed_style: Some(ArgumentStyle::Keyword),
            desired_style: ArgumentStyle::Keyword
        })?;
        ser.serialize_field("kw_defaults", &DefaultArgSerializer {
            args: self.keyword_args,
            positional: false
        })?;
        ser.serialize_field("kwarg", &self.keyword_vararg)?;
        ser.serialize_field("defaults", &DefaultArgSerializer {
            args: self.positional_args,
            positional: true
        })?;
        ser.end()
    }
}

#[derive(Educe, Debug, Clone)]
#[educe(PartialEq, Eq, Hash)]
/*
 * NOTE: This is *not* how its serialized in the Python AST.
 * I've made significant changes to the structure, so its completely incompatible (but easier to use).
 * However, the 'Arguments' structure *does* serialize in a compatible way.
 */
#[cfg_attr(feature = "serialize", derive(Serialize))]
pub struct Arg<'a> {
    pub name: Ident<'a>,
    pub annotation: Option<Expr<'a>>,
    #[cfg_attr(feature = "serialize", serde(skip_serializing_if = "Option::is_none"))]
    pub type_comment: Option<&'a str>,
    pub default_value: Option<Expr<'a>>,
    pub style: ArgumentStyle,
    #[educe(Hash(ignore))]
    #[educe(PartialEq(ignore))]
    pub span: Span,
}
#[derive(PartialEq, Eq, Hash, Debug, Copy, Clone)]
/*
 * NOTE: The styles actually have an expected ordering.
 * If it is not met, the 'Arguments' struct is invalid.
 */
#[derive(PartialOrd, Ord)]
#[cfg_attr(feature = "serialize", derive(Serialize))]
#[cfg_attr(feature = "serialize", serde(rename_all = "snake_case"))]
pub enum ArgumentStyle {
    Positional,
    PositionalOnly,
    Vararg,
    /*
     * NOTE: This functions as 'kwonlyargs' in the regular AST.
     */
    Keyword,
    KeywordVararg
}
impl<'a> AstNode for Arg<'a> {}
impl<'a> Spanned for Arg<'a> {
    #[inline]
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Educe, Debug, Clone)]
#[educe(PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serialize", derive(Serialize))]
pub struct Keyword<'a> {
    pub name: Ident<'a>,
    pub value: Expr<'a>,
    #[educe(Hash(ignore))]
    #[educe(PartialEq(ignore))]
    pub span: Span,
}
impl<'a> AstNode for Keyword<'a> {}
impl<'a> Spanned for Keyword<'a> {
    #[inline]
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Educe, Debug, Clone)]
#[educe(PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serialize", derive(Serialize))]
pub struct Alias<N: AstNode> {
    pub name: N,
    pub alias: Option<N>,
    #[educe(Hash(ignore))]
    #[educe(PartialEq(ignore))]
    pub span: Span,
}
impl<N: AstNode> Spanned for Alias<N> {
    #[inline]
    fn span(&self) -> Span {
        self.span
    }
}
impl<N: AstNode> AstNode for Alias<N> {}

#[derive(Educe, Debug, Clone)]
#[educe(PartialEq, Eq, Hash)]
pub enum RelativeModule<'a> {
    Relative {
        /// The name of the module that is being imported, relative to a given level
        ///
        /// This could be `None`, corresponding to the "from .. import <names>" case
        relative_path: Option<ModulePath<'a>>,
        /// The relative level of the import
        ///
        /// This cannot logically be zero (since that would be an absolute import)
        level: NonZeroU32,
        /// The complete span of the import, including any leading dots
        #[educe(Hash(ignore))]
        #[educe(PartialEq(ignore))]
        span: Span,
    },
    Absolute {
        /// The absolute path to the import
        path: ModulePath<'a>,
    }
}
impl<'a> Spanned for RelativeModule<'a> {
    fn span(&self) -> Span {
        match *self {
            RelativeModule::Relative { span, .. } => span,
            RelativeModule::Absolute { ref path } => path.span()
        }
    }
}
#[cfg(feature = "serialize")]
impl<'a> ::serde::Serialize for RelativeModule<'a> {
    fn serialize<S>(&self, serializer: S) -> Result<<S as Serializer>::Ok, <S as Serializer>::Error> where
        S: Serializer {
        use serde::ser::SerializeStruct;
        let mut ser = serializer.serialize_struct("RelativeModule", 2)?;
        let (level, path): (u32, Option<&ModulePath<'a>>) = match *self {
            RelativeModule::Relative { ref relative_path, level, span: _ } => {
                (level.get(), relative_path.as_ref())
            }
            RelativeModule::Absolute { ref path } => {
                (0, Some(path))
            }
        };
        ser.serialize_field("level", &level)?;
        ser.serialize_field("module", &path)?;
        ser.end()
    }
}
impl<'a> AstNode for RelativeModule<'a> {}

#[derive(PartialEq, Eq, Hash, Debug, Clone)]
pub struct ModulePath<'a> {
    pub parts: &'a [Ident<'a>],
}
#[cfg(feature = "serialize")]
impl<'a> Serialize for ModulePath<'a> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error> where S: Serializer {
        if serializer.is_human_readable() {
            serializer.serialize_str(&format!("{}", self))
        } else {
            self.parts.serialize(serializer)
        }
    }
}
impl<'a> Display for ModulePath<'a> {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        use std::fmt::Write;
        let mut first = true;
        for part in self.parts {
            if !first {
                f.write_char('.')?;
            }
            f.write_str(part.text())?;
            first = false;
        }
        Ok(())
    }
}
impl<'a> AstNode for ModulePath<'a> {}
impl<'a> Spanned for ModulePath<'a> {
    #[inline]
    fn span(&self) -> Span {
        Span {
            start: self.parts[0].span.start,
            end: self.parts.last().unwrap().span.end
        }
    }
}
#[derive(Educe, Debug, Clone)]
#[educe(PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serialize", derive(Serialize))]
pub struct WithItem<'a> {
    pub context_expr: Expr<'a>,
    pub optional_vars: Option<Expr<'a>>,
    #[educe(PartialEq(ignore))]
    #[educe(Hash(ignore))]
    pub span: Span
}
impl<'a> AstNode for WithItem<'a> {}
impl<'a> Spanned for WithItem<'a> {
    #[inline]
    fn span(&self) -> Span {
        self.span
    }
}

#[derive(Educe, Debug, Clone)]
#[educe(PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serialize", derive(Serialize))]
pub struct MatchCase<'a> {
    pub pattern: &'a Pattern<'a>,
    pub guard: Option<Expr<'a>>,
    pub body: &'a [Stmt<'a>],
    #[educe(PartialEq(ignore))]
    #[educe(Hash(ignore))]
    pub span: Span
}
impl<'a> Spanned for MatchCase<'a> {
    #[inline]
    fn span(&self) -> Span {
        self.span
    }
}
impl<'a> AstNode for MatchCase<'a> {}

#[derive(Educe, Debug, Clone)]
#[educe(PartialEq, Eq, Hash)]
#[cfg_attr(feature = "serialize", derive(Serialize))]
pub enum Pattern<'a> {
    MatchValue {
        /// The span of the source
        #[educe(Hash(ignore))]
        #[educe(PartialEq(ignore))]
        span: Span,
        value: Expr<'a>,
    },
    MatchSingleton {
        /// The span of the source
        #[educe(Hash(ignore))]
        #[educe(PartialEq(ignore))]
        span: Span,
        value: Constant<'a>,
    },
    MatchSequence {
        /// The span of the source
        #[educe(Hash(ignore))]
        #[educe(PartialEq(ignore))]
        span: Span,
        patterns: &'a [Pattern<'a>],
    },
    MatchMapping {
        /// The span of the source
        #[educe(Hash(ignore))]
        #[educe(PartialEq(ignore))]
        span: Span,
        keys: &'a [Expr<'a>],
        patterns: &'a [Pattern<'a>],
        rest: Option<Ident<'a>>,
    },
    MatchClass {
        /// The span of the source
        #[educe(Hash(ignore))]
        #[educe(PartialEq(ignore))]
        span: Span,
        cls: Expr<'a>,
        patterns: &'a [Pattern<'a>],
        kwd_attrs: &'a [Ident<'a>],
        kwd_patterns: &'a [Pattern<'a>],
    },
    MatchStar {
        /// The span of the source
        #[educe(Hash(ignore))]
        #[educe(PartialEq(ignore))]
        span: Span,
        name: Option<Ident<'a>>,
    },
    MatchAs {
        /// The span of the source
        #[educe(Hash(ignore))]
        #[educe(PartialEq(ignore))]
        span: Span,
        pattern: Option<&'a Pattern<'a>>,
        name: Option<Ident<'a>>,
    },
    MatchOr {
        /// The span of the source
        #[educe(Hash(ignore))]
        #[educe(PartialEq(ignore))]
        span: Span,
        patterns: &'a [Pattern<'a>],
    },
}
impl<'a> Spanned for Pattern<'a> {
    fn span(&self) -> Span {
        match *self {
            Pattern::MatchValue { span, .. } |
            Pattern::MatchSingleton { span, .. } |
            Pattern::MatchSequence { span, .. } |
            Pattern::MatchMapping { span, .. } |
            Pattern::MatchClass { span, .. } |
            Pattern::MatchStar { span, .. } |
            Pattern::MatchAs { span, .. } |
            Pattern::MatchOr { span, .. } => span,
        }
    }
}
impl<'a> AstNode for Pattern<'a> {}

#[derive(PartialEq, Eq, Hash, Debug, Clone)]
#[cfg_attr(feature = "serialize", derive(Serialize))]
pub struct TypeIgnore<'a> {
    pub lineno: i32,
    pub tag: &'a str,
}

